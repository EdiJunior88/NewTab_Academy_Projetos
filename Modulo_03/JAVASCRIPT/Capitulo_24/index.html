<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="index.css">
  <title>Assincronicidade*</title>
</head>
<body>
  <h1>Assincronicidade*</h1>

  <p>üìç Para refor√ßar:</p>

  <p>Na maioria das vezes, o c√≥digo JavaScript √© executado de forma s√≠ncrona. Isso significa que uma linha de c√≥digo √© executada, a pr√≥xima √© executada e assim por diante.</p>

  <p>Tudo est√° como voc√™ espera e como funciona na maioria das linguagens de programa√ß√£o. No entanto, h√° momentos em que voc√™ n√£o pode esperar apenas pela execu√ß√£o de uma linha de c√≥digo. Voc√™ n√£o pode esperar apenas 2 segundos para carregar um arquivo grande e interromper o programa completamente. Voc√™ n√£o pode simplesmente esperar que um recurso de rede seja baixado antes de fazer outra coisa.</p>
  
  <p>JavaScript resolve esse problema usando callbacks. Um dos exemplos mais simples de como usar callbacks √© com temporizadores. Os temporizadores n√£o fazem parte do JavaScript, mas s√£o fornecidos pelo navegador e pelo Node.js. Vamos falar sobre um dos temporizadores que temos: setTimeout().</p>
  
  <p>A fun√ß√£o setTimeout() aceita 2 argumentos: uma fun√ß√£o e um n√∫mero. O n√∫mero s√£o os milissegundos que devem passar antes da execu√ß√£o da fun√ß√£o.</p>
  
  <p>Exemplo:</p>
  
  <pre>
    <code>
      setTimeout(() =&gt {
        console.log('ol√° mundo')
      }, 2000)
    </code>
  </pre>

  <p>A fun√ß√£o que cont√©m a linha console.log('ol√° mundo') ser√° executada ap√≥s 2 segundos. Se voc√™ adicionar um console.log('antes') antes da fun√ß√£o e console.log('depois'):</p>
  
  <pre>
    <code>
      console.log('antes')
        setTimeout(() =&gt {
          console.log('ol√° mundo')
      }, 2000)
      console.log('depois')
    </code>
  </pre>

  <p>Voc√™ ver√° isso acontecendo no seu console:</p>
  
  <pre>
    <code>
      antes
      depois
      ol√° mundo
    </code>
  </pre>

  <p>A fun√ß√£o de callbacks √© executada assincronamente.</p>
  
  <p>Podemos implementar retornos de chamada em nosso c√≥digo. Definimos uma fun√ß√£o que aceita um par√¢metro de callback, que √© uma fun√ß√£o. Quando o c√≥digo est√° pronto para chamar o retorno de chamada, n√≥s o chamamos passando o resultado:</p>
  
  <pre>
    <code>
      const doSomething = callback =&gt {
        //Faz algo
        const result = /* .. */
        callback(result)
      }
    </code>
  </pre>

  <p>O c√≥digo que usa essa fun√ß√£o usaria assim:</p>
  
  <pre>
    <code>
      doSomething(result =&gt {
        console.log(result);
      })
    </code>
  </pre>
</body>
</html>