<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="index.css">
  <title>Promise</title>
</head>
<body>
  <h1>Promise</h1>

  <p>üìç Para refor√ßar:</p>

  <p>As Promises s√£o uma maneira alternativa de lidar com c√≥digo ass√≠ncrono. Como vimos na parte anterior, com callbacks estar√≠amos passando uma fun√ß√£o para outra chamada de fun√ß√£o que seria chamada quando terminasse o processamento.</p>

  <p>Como isso:</p>

  <pre>
    <code>
      doSomething(result =&gt {
        console.log(result);
      })
    </code>
  </pre>

  <p>Quando o c√≥digo doSomething() termina, chama a fun√ß√£o recebida como um par√¢metro:</p>

  <pre>
    <code>
      const doSomething = callback =&gt {
        //Faz algo
        const result = /* .. */
        callback(result)
      }
    </code>
  </pre>

  <p>O principal problema dessa abordagem √© que, se precisarmos usar o resultado dessa fun√ß√£o no restante do c√≥digo, todo o c√≥digo dever√° estar aninhado dentro do retorno de chamada e, se precisarmos fazer 2-3 retornos de chamada, inserimos o que √© geralmente definido ‚Äúcallback hell‚Äù com muitos n√≠veis de fun√ß√µes recuados em outras fun√ß√µes:</p>

  <pre>
    <code>
      doSomething(result =&gt {
        doSomethingElse(anotherResult =&gt {
          doSomethingElseAgain(yetAnotherResult =&gt {
            console.log(result);
          })
        })
      })
    </code>
  </pre>

  <p>Promises s√£o uma maneira de lidar com isso.</p>

  <p>Em vez de fazer:</p>

  <pre>
    <code>
      doSomething(result =&gt {
        console.log(result);
      })
    </code>
  </pre>

  <p>Chamamos uma fun√ß√£o baseada em promise desta maneira:</p>

  <pre>
    <code>
      doSomething()
        .then(result =&gt {
          console.log(result);
        })
    </code>
  </pre>

  <p>Primeiro chamamos a fun√ß√£o, ent√£o temos um m√©todo then() chamado quando a fun√ß√£o termina.</p>

  <p>√â comum detectar erros usando um m√©todo catch():</p>

  <pre>
    <code>
      doSomething()
        .then(result =&gt {
          console.log(result)
        }) .catch(error =&gt {
          console.log(error);
        })
    </code>
  </pre>

  <p>Agora, para poder usar essa sintaxe, a implementa√ß√£o da fun√ß√£o doSomething() deve ser um pouco especial, deve usar Promises.    </p>

  <p>Em vez de declarar como uma fun√ß√£o normal:</p>

  <pre>
    <code>
      const doSomething = () =&gt {
      }
    </code>
  </pre>

  <p>N√≥s o declaramos como um objeto de promises:</p>

  <pre>
    <code>
      const doSomething = new Promise();
    </code>
  </pre>

  <p>E passamos uma fun√ß√£o no construtor Promise:</p>

  <pre>
    <code>
      const doSomething = new Promise(() =&gt { })
    </code>
  </pre>

  <p>Esta fun√ß√£o recebe 2 par√¢metros. A primeira √© uma fun√ß√£o que chamamos para resolver a promise, a segunda √© uma fun√ß√£o que chamamos para rejeitar a promise.</p>

  <pre>
    <code>
      const doSomething = new Promise(
        (resolve, reject) =&gt {
      })
    </code>
  </pre>

  <p>Resolver uma promise significa conclu√≠-la com sucesso (o que resulta em chamar o m√©todo then() em qualquer que seja o uso). Rejeitar uma promise significa encerr√°-la com um erro (o que resulta em chamar o m√©todo catch() no que quer que seja usado).</p>

  <p>Aqui est√° como podemos passar um par√¢metro para as fun√ß√µes de resolu√ß√£o e rejei√ß√£o, de qualquer tipo que desejar: </p>

  <pre>
    <code>
      const doSomething = new Promise(
        (resolve, reject) =&gt {
          //faz algo
          const success = /* ‚Ä¶ */
          if (success) {
            resolve('ok');
          } else {
            reject('erro encontrado');
          }
        })
    </code>
  </pre>
</body>
</html>