<!DOCTYPE html>
<html lang="pt-br">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="index.css">
  <title>Classes abstratas</title>
</head>

<body>
  <h1>Classes abstratas</h1>

  <h2>Classes Abstratas: o melhor dos mundos</h2>

  <p>Uma classe abstrata √© uma esp√©cie de meio-termo entre interfaces tradicionais e classes, no sentido em que, assim como uma interface, voc√™ n√£o pode inicializa-la utilizando o comando <code>new</code>, como tamb√©m pode definir m√©todos tanto abstratos (que n√£o cont√©m implementa√ß√£o, apenas defini√ß√£o, assim como nas interfaces), como tamb√©m incluindo uma implementa√ß√£o "b√°sica" do m√©todo, que pode ou n√£o ser substitu√≠da depois.</p>

  <p>Qualquer classe que extende uma classe abstrata segue as regras de heran√ßa de classes tradicionais (ou seja, s√≥ pode possuir uma classe base), al√©m tamb√©m das regras de implementa√ß√£o de interfaces (ou seja, precisa implementar todas fun√ß√µes marcadas como abstratas).</p>

  <p>Vamos para um exemplo pr√°tico e imaginar que estamos criando uma classe base chamada <code>Foguete</code>, que ser√° uma classe abstrata e ser√° base para implementa√ß√£o de nossos foguetes para Lua e para Marte. Nesta classe, apenas duas fun√ß√µes est√£o implementadas, uma sendo <code>iniciar_sequencia_lancamento()</code>, que define toda sequ√™ncia de lan√ßamento dos foguetes, e <code>contagem()</code>, que faz a contagem regressiva para o lan√ßamento:</p>

  <pre>
    abstract class Foguete {
    
      // Fun√ß√£o tradicional e implementada na classe abstrata
      iniciar_sequencia_lancamento () {
    
        // Inicia contagem regressiva
        this.contagem()
    
        // Informa sobre o lan√ßamento do foguete
        console.log(`Lan√ßando o foguete ${this.pegar_nome()} com destino ${this.pegar_destino()}!`)
    
        // Faz o lan√ßamento!
        this.lancar()
      }
    
      // Fun√ß√£o que vai fazer a contagem regressiva do lan√ßamento
      contagem () {
        console.log(`10... 9... 8... 7... 6... 5... 4... 3... 2... 1...`)
      }
    
      // Fun√ß√£o abstrata que deve retornar o nome do foguete, sem nenhum tipo de retorno
      abstract lancar ()
    
      // Fun√ß√£o abstrata que deve retornar o nome do foguete, com tipo de retorno "string"
      abstract pegar_nome () : string
    
      // Fun√ß√£o abstrata que deve retornar o destino do foguete, com tipo de retorno "string"
      abstract pegar_destino () : string
    }
  </pre>

  <p>Como voc√™ pode ver, temos algumas fun√ß√µes abstratas separadas que dever√£o ser implementadas por nossos foguetes antes deles serem lan√ßados, como <code>lancar()</code>, <code>pegar_nome()</code> e <code>pegar_destino()</code>. Algumas destas fun√ß√µes possuem um tipo de retorno, denominado pelo <code>: string</code> nas defini√ß√µes. Isto indica que estas fun√ß√µes dever√£o retornar um valor do tipo <code>string</code> e tamb√©m, quando as utilizarmos, nos garante que este ser√° o tipo que a fun√ß√£o ir√° nos retornar. Defini√ß√µes sem anota√ß√£o alguma podem retornar tanto nenhum como qualquer tipo de valor.</p>

  <p>Abaixo, vamos criar ent√£o o foguete Saturn V, que vai levar nossos astronautas para a Lua:</p>

  <pre>
    class SaturnV extends Foguete {
    
      // Implementamos a fun√ß√£o "lancar"
      lancar () {
        console.log('Foguete lan√ßado!')
      }
    
      // Implementamos a fun√ß√£o "pegar_nome"
      pegar_nome () : string {
        return 'Saturn V'
      }
    
      // Implementamos a fun√ß√£o "pegar_nome"
      pegar_destino () : string {
        return 'Lua'
      }
    }
  </pre>

  <p>Nossa implementa√ß√£o √© bem simples, apenas declaramos que nosso foguete ir√° para a Lua, que possui o nome "Saturn V" e que, ao ser lan√ßado, ir√° imprimir na tela o texto "Foguete lan√ßado!". Vamos tamb√©m implementar o foguete Falcon 9, desta vez com uma contagem regressiva um pouco mais reduzida:</p>

  <pre>
    class Falcon9 extends Foguete {
    
      // Modificamos a fun√ß√£o "contagem" para algo mais curto
      contagem () {
        console.log(`5... 4... 3... 2... 1...`)
      }
    
      // Implementamos a fun√ß√£o "lancar"
      lancar () {
        console.log('Foguete lan√ßado!')
      }
    
      // Implementamos a fun√ß√£o "pegar_nome"
      pegar_nome () : string {
        return 'Falcon 9'
      }
    
      // Implementamos a fun√ß√£o "pegar_nome"
      pegar_destino () : string {
        return 'Marte'
      }
    }
  </pre>

  <p>Como voc√™ pode ver, a implementa√ß√£o √© similar √† do foguete Saturn V, por√©m estamos sobrescrevendo a fun√ß√£o <code>contagem()</code> com nossa pr√≥pria implementa√ß√£o. Com isto, ao executar o programa, nossa nova implementa√ß√£o ser√° utilizada sempre que a fun√ß√£o <code>contagem()</code> for chamada para um foguete do tipo Falcon9, independente se a fun√ß√£o estiver sendo chamada de dentro da classe abstrata <code>Foguete</code> ou da classe final <code>Falcon9</code></p>

  <p>Por fim, vamos criar uma fun√ß√£o bem simples que recebe um objeto do tipo <code>Foguete</code> e inicia sua sequ√™ncia de lan√ßamento, assim como lan√ßar nossos dois foguetes! \√µ/</p>

  <pre>
    // Nossa fun√ß√£o que vai lan√ßar uma miss√£o, precisamos passar um foguete como argumento
    function lancar_missao_espacial (foguete : Foguete) {
    
      // Lan√ßamos o foguete!
      foguete.iniciar_sequencia_lancamento()
    
    }
    
    // Vamos lan√ßar o Saturn V com destino Lua!
    lancar_missao_espacial(new SaturnV)
    
    // Vamos lan√ßar o Saturn V com destino Marte!
    
    lancar_missao_espacial(new Falcon9)
  </pre>

  <p>Pronto! Nossos foguetes foram lan√ßados e estamos prontos para explorar a Lua e Marte! üöÄ</p>

</body>

</html>