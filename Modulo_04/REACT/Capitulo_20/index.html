<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="index.css">
  <title>Refor√ßando e complementando conte√∫do</title>
</head>
<body>
  <h1>Refor√ßando e complementando conte√∫do</h1>

  <p>Por conta do modo como o React trata o ciclo de renderiza√ß√£o dos componentes, n√£o podemos simplesmente trocar o valor de uma vari√°vel atrelada a uma intera√ß√£o do usu√°rio. Se por exemplo a gente tivesse um input: <mark>&ltinput type="text" value={variavel}&gt</mark>, o que aconteceria se a gente digitasse algo?</p>

  <p>O React detectaria a mudan√ßa, dispararia uma nova renderiza√ß√£o e‚Ä¶ nada! Isso porque ele foi instru√≠do a setar o valor do input para a vari√°vel, mas n√£o a configurar o valor dessa vari√°vel para o valor do input. Como far√≠amos isso, ent√£o? Podemos usar a palavra chave onChange que identifica o evento de mudan√ßa de valor e executa alguma fun√ß√£o, que no nosso caso seria colocar o valor da vari√°vel igual ao do input.</p>

  <p>‚ùó Obs.: Confira a lista dos eventos React aqui: <a href="https://pt-br.reactjs.org/docs/events.html">https://pt-br.reactjs.org/docs/events.html</a></p>

  <p>Ent√£o se fiz√©ssemos algo como:</p>

  <img src="img/img01.png" alt="">

  <p>Tudo funcionaria, certo? Bom‚Ä¶ n√£o. O ponto aqui √© que, como o React dispara renderiza√ß√µes dos lugares que sofreram mudan√ßas ele precisa o tempo todo manter um controle sobre quais vari√°veis tem quais valores em quais momentos. Em outras palavras ele precisa sempre saber como uma vari√°vel est√°, ou o seu estado. E, para manter a consist√™ncia dos dados da aplica√ß√£o (ou seja, evitar que tudo vire uma bagun√ßa), o React permite apenas a intera√ß√£o com o estado das vari√°veis de uma √∫nica forma padronizada.</p>

  <p>Para tanto, usamos uma propriedade especial da classe <i>Component</i>, chamada state. Repare, falamos que √© da classe <i>Component</i>, certo? Isso quer dizer que, a priori, n√£o conseguimos manipular estado em componentes funcionais. Essa √© umas das maiores diferen√ßas entre os dois. Tecnicamente, n√≥s podemos usar estado nesses casos, mas usamos um outro recurso mais moderno do React: os chamados <i>Hooks</i>.</p>

  <p>Definimos o state ent√£o como uma propriedade de nossa classe, mais especificamente um objeto:</p>

  <img src="img/img02.png" alt="">

  <p>Podemos acessar ent√£o as entradas deste estado com o this em outros lugares de nosso c√≥digo:</p>

  <img src="img/img03.png" alt="">

  <p>Mas mesmo assim‚Ä¶ ainda n√£o funciona! Isso porque, ainda, n√£o estamos usando o estado do modo como o React quer. Por motivos de seguran√ßa o React n√£o reconhece altera√ß√µes (chamadas tamb√©m de "muta√ß√µes") diretas no estado, como em: <mark>this.state.variavel = $event.target.value;</mark>. Para alterar o valor dessa entrada, precisamos usar um m√©todo espec√≠fico: this.setState(). </p>

  <p>Esse √© um m√©todo especial da classe <i>Component</i> que altera o valor do objeto state de maneira que o React reconhe√ßa. Como par√¢metro passamos um novo objeto contendo as entradas que queremos alterar. Por exemplo.: <mark>this.setState({variavel: $event.target.value});</mark>. Esse m√©todo vai ent√£o mesclar os dois objetos, implementando nossas altera√ß√µes, mas sem perder ou sobrescrever as demais propriedades do estado que n√£o mencionamos. Se testarmos agora, veremos que, finalmente, nosso input funciona.</p>

  <p>Pode parecer muito complicado para uma opera√ß√£o aparentemente t√£o simples, mas toda essa rigidez √© necess√°ria para o modo como o React interage com o DOM funcionar e, se voc√™ parar pra pensar, n√£o √© de todo ruim. Por te for√ßar a usar esses m√©todos, o React te instrui a controlar com mais cuidado suas vari√°veis e como o usu√°rio interage com elas, o que pode prevenir muitos comportamentos errados em sua aplica√ß√£o que seriam muito dif√≠ceis de debugar e identificar.</p>

  <p>Outro detalhe importante: √© uma boa pr√°tica usar o m√≠nimo poss√≠vel de componentes que manipulam estado. Isso √© exatamente porque √© muito f√°cil se perder na ger√™ncia do estado entre componentes se h√° m√∫ltiplos desses em uma √∫nica p√°gina. Se tr√™s dos nossos elementos podem observar uma vari√°vel imagina a bagun√ßa que seria? Uma regra simples que podemos seguir √© que componentes que descrevem uma p√°gina podem gerenciar estado, enquanto os demais componentes que a comp√µe n√£o, se preocupando apenas em renderizar conte√∫do de maneira "burra". Isso permite que sejam mais facilmente reutilizados e, de quebra, mant√©m nosso c√≥digo mais claro.</p>

  <p>Enquanto estamos nesse assunto, podemos abordar tamb√©m sobre eventos. Vamos explicar ent√£o os m√©todos executados nos exemplos acima. De cara usamos o interpolador porque estamos usando uma express√£o JS, certo? Mas, se estou usando uma fun√ß√£o, por que n√£o a declaro como funcao() ao inv√©s de apenas funcao? Muito simples: quando escrevemos o primeiro estamos na verdade executando a fun√ß√£o uma vez. Isso quer dizer que o React renderiza o elemento, executa a fun√ß√£o e acabou. E toda vez que o evento disparar, ele vai quebrar, porque n√£o consegue referenciar algo que j√° foi executado.</p>

  <p>Quando enviamos apenas o nome do m√©todo (this.metodo) ou fun√ß√£o, estamos na verdade enviando a refer√™ncia do que queremos que o React execute toda vez. E por padr√£o o React j√° envia uma c√≥pia do evento em si com o par√¢metro, ent√£o n√£o precisamos nos preocupar com isso. Mas e se quisermos enviar par√¢metros? Temos alguns jeitos:</p>

  <img src="img/img04.png" alt="">

  <p>Ok, o que √© tudo isso? No primeiro, atrelamos um m√©todo √† estrutura geral usando uma fun√ß√£o especial do React, o bind, e em seguida listamos os par√¢metros dessa fun√ß√£o. No segundo caso criamos uma fun√ß√£o (arrow function) que recebe o par√¢metro e executa a fun√ß√£o com o par√¢metro toda vez que o evento dispara. Como n√£o definimos uma vari√°vel especial para o evento explicitamente, devemos assumir na declara√ß√£o do m√©todo/fun√ß√£o que o evento √© sempre o primeiro par√¢metro enviado. Desse modo conseguimos enviar refer√™ncias de fun√ß√£o com par√¢metros sem precisar, necessariamente, declarar o evento.</p>

  <p>Outra coisa importante √© que podemos passar como propriedades n√£o somente dados, mas tamb√©m m√©todos. Por que isso seria importante? Lembra que alguns componentes n√£o conseguem manipular estado? Como ent√£o podemos criar componentes interativos?</p>

  <p>Devemos for√ßar ger√™ncia de estado em cada um? De jeito nenhum! O mais inteligente √© manter o padr√£o que discutimos antes e, a partir do componente com estado, mandar os eventos que o manipulam como uma propriedade!</p>

  <p>Seguindo nosso exemplo, e se quis√©ssemos clicar em itens da lista que completamos para apag√°-lo? Primeiramente, ter√≠amos que mover nossas vari√°veis para o state:</p>

  <img src="img/img05.png" alt="">

  <p>E criar um m√©todo para remover o elemento:</p>

  <img src="img/img06.png" alt="">

  <p>Agora basta enviar o √∫ltimo como uma propriedade <mark>&ltLista lista="listaCompras" elementos={this.state.listaCompras} deleted={this.deleteElementHandler}/&gt</mark> e podemos agora us√°-lo dentro de nosso componente. Se dentro dele fizermos:</p>

  <img src="img/img07.png" alt="">

  <p>E podemos atrelar o m√©todo com o evento onClick para, de dentro do nosso componente, afetar o estado do componente pai e eliminar um elemento da lista.</p>

  <hr>

  <p>üîé Fonte e/ou material complementar:</p>

  <p>Voc√™ tamb√©m encontra mais informa√ß√µes na documenta√ß√£o oficial do React: <a href="https://pt-br.reactjs.org/docs/state-and-lifecycle.html">https://pt-br.reactjs.org/docs/state-and-lifecycle.html</a></p>
</body>
</html>